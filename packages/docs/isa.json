{
  "version": "1.0",
  "note": "Some instructions are aliases with identical opcodes: JE/JZ (0x74), JNE/JNZ (0x75)",
  "instructions": [
    {
      "mnemonic": "MOV",
      "opcode": "0x89",
      "operands": ["reg/mem", "reg/imm"],
      "description": "Move data",
      "cycles": 1,
      "flags": [],
      "examples": [
        "MOV EAX, 42        ; Load immediate",
        "MOV EAX, ECX       ; Register to register",
        "MOV EAX, 0xF100    ; Read from I/O",
        "MOV 0xF000, 1      ; Write to I/O",
        "MOV AL, 'H'        ; Move character to low byte of EAX",
        "MOV AH, 0x0E       ; Move to high byte of EAX",
        "MOV DL, 65         ; Move to low byte of EDX"
      ]
    },
    {
      "mnemonic": "XCHG",
      "opcode": "0x87",
      "operands": ["reg", "reg"],
      "description": "Exchange values between two registers",
      "cycles": 1,
      "flags": [],
      "examples": [
        "XCHG EAX, ECX      ; Swap EAX and ECX"
      ]
    },
    {
      "mnemonic": "LEA",
      "opcode": "0x8D",
      "operands": ["reg", "imm"],
      "description": "Load effective address",
      "cycles": 1,
      "flags": [],
      "examples": [
        "LEA EAX, 0x1000    ; Load address into EAX"
      ]
    },
    {
      "mnemonic": "MOVZX",
      "opcode": "0x0FB6",
      "operands": ["reg", "reg/imm"],
      "description": "Move with zero extend (8-bit to 32-bit)",
      "cycles": 1,
      "flags": [],
      "examples": [
        "MOVZX EAX, ECX     ; Move low byte of ECX to EAX, zero-extend"
      ]
    },
    {
      "mnemonic": "MOVSX",
      "opcode": "0x0FBE",
      "operands": ["reg", "reg/imm"],
      "description": "Move with sign extend (8-bit to 32-bit)",
      "cycles": 1,
      "flags": [],
      "examples": [
        "MOVSX EAX, ECX     ; Move low byte of ECX to EAX, sign-extend"
      ]
    },
    {
      "mnemonic": "ADD",
      "opcode": "0x01",
      "operands": ["reg", "reg"],
      "description": "Add two registers and store result",
      "cycles": 1,
      "flags": ["Z", "C", "O", "S"],
      "examples": [
        "ADD EAX, ECX       ; EAX = EAX + ECX"
      ]
    },
    {
      "mnemonic": "SUB",
      "opcode": "0x29",
      "operands": ["reg", "reg"],
      "description": "Subtract two registers",
      "cycles": 1,
      "flags": ["Z", "C", "O", "S"],
      "examples": [
        "SUB EAX, ECX       ; EAX = EAX - ECX"
      ]
    },
    {
      "mnemonic": "CMP",
      "opcode": "0x39",
      "operands": ["reg", "reg/imm"],
      "description": "Compare (SUB without storing result)",
      "cycles": 1,
      "flags": ["Z", "C", "O", "S"],
      "examples": [
        "CMP EAX, 0         ; Compare EAX with 0",
        "CMP EAX, ECX       ; Compare EAX with ECX"
      ]
    },
    {
      "mnemonic": "AND",
      "opcode": "0x21",
      "operands": ["reg", "reg"],
      "description": "Bitwise AND two registers",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": [
        "AND EAX, ECX       ; EAX = EAX & ECX"
      ]
    },
    {
      "mnemonic": "OR",
      "opcode": "0x09",
      "operands": ["reg", "reg/imm"],
      "description": "Bitwise OR two registers or register with immediate",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": [
        "OR EAX, ECX        ; EAX = EAX | ECX",
        "OR EAX, 0x0F       ; EAX = EAX | 0x0F"
      ]
    },
    {
      "mnemonic": "XOR",
      "opcode": "0x31",
      "operands": ["reg", "reg/imm"],
      "description": "Bitwise XOR two registers or register with immediate",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": [
        "XOR EAX, ECX       ; EAX = EAX ^ ECX",
        "XOR EAX, EAX       ; Clear EAX to 0"
      ]
    },
    {
      "mnemonic": "NOT",
      "opcode": "0xF7",
      "operands": ["reg"],
      "description": "Bitwise NOT (one's complement)",
      "cycles": 1,
      "flags": [],
      "examples": [
        "NOT EAX            ; EAX = ~EAX"
      ]
    },
    {
      "mnemonic": "NEG",
      "opcode": "0xF7",
      "operands": ["reg"],
      "description": "Two's complement negation",
      "cycles": 1,
      "flags": ["Z", "C", "O", "S"],
      "examples": [
        "NEG EAX            ; EAX = -EAX"
      ]
    },
    {
      "mnemonic": "TEST",
      "opcode": "0x85",
      "operands": ["reg", "reg/imm"],
      "description": "Logical AND (affects flags only, doesn't store result)",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": [
        "TEST EAX, 0xFF     ; Check if any bits set in lower byte",
        "TEST EAX, ECX      ; Test bits"
      ]
    },
    {
      "mnemonic": "SHL",
      "opcode": "0xC1",
      "operands": ["reg", "imm/reg"],
      "description": "Shift left",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": [
        "SHL EAX, 4         ; Shift left by 4 positions"
      ]
    },
    {
      "mnemonic": "SHR",
      "opcode": "0xC1",
      "operands": ["reg", "imm/reg"],
      "description": "Shift right (logical, zero-fill)",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": [
        "SHR EAX, 2         ; Shift right by 2 positions"
      ]
    },
    {
      "mnemonic": "SAR",
      "opcode": "0xC1",
      "operands": ["reg", "imm/reg"],
      "description": "Shift arithmetic right (sign-extend)",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": [
        "SAR EAX, 3         ; Arithmetic shift right by 3"
      ]
    },
    {
      "mnemonic": "ROL",
      "opcode": "0xC1",
      "operands": ["reg", "imm/reg"],
      "description": "Rotate left",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": [
        "ROL EAX, 8         ; Rotate left by 8 positions"
      ]
    },
    {
      "mnemonic": "ROR",
      "opcode": "0xC1",
      "operands": ["reg", "imm/reg"],
      "description": "Rotate right",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": [
        "ROR EAX, 8         ; Rotate right by 8 positions"
      ]
    },
    {
      "mnemonic": "CMP",
      "opcode": "0x39",
      "operands": ["reg", "reg"],
      "description": "Compare two values (SUB without storing result)",
      "cycles": 1,
      "flags": ["Z", "C", "O", "S"]
    },
    {
      "mnemonic": "INC",
      "opcode": "0xFF",
      "operands": ["reg"],
      "description": "Increment register by 1",
      "cycles": 1,
      "flags": ["Z", "O", "S"],
      "examples": [
        "INC EAX            ; EAX = EAX + 1"
      ]
    },
    {
      "mnemonic": "DEC",
      "opcode": "0xFF",
      "operands": ["reg"],
      "description": "Decrement register by 1",
      "cycles": 1,
      "flags": ["Z", "O", "S"],
      "examples": [
        "DEC ECX            ; ECX = ECX - 1"
      ]
    },
    {
      "mnemonic": "MUL",
      "opcode": "0xF7",
      "operands": ["reg/imm"],
      "description": "Unsigned multiply (EAX * src -> EDX:EAX)",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": [
        "MUL ECX            ; EAX = EAX * ECX, overflow in EDX"
      ]
    },
    {
      "mnemonic": "IMUL",
      "opcode": "0xF7",
      "operands": ["reg/imm"],
      "description": "Signed multiply (EAX * src -> EAX)",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": [
        "IMUL ECX           ; EAX = EAX * ECX (signed)"
      ]
    },
    {
      "mnemonic": "DIV",
      "opcode": "0xF7",
      "operands": ["reg/imm"],
      "description": "Unsigned divide (EAX / src -> quotient in EAX, remainder in EDX)",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": [
        "DIV ECX            ; EAX = EAX / ECX, EDX = remainder"
      ]
    },
    {
      "mnemonic": "IDIV",
      "opcode": "0xF7",
      "operands": ["reg/imm"],
      "description": "Signed divide (EAX / src -> quotient in EAX, remainder in EDX)",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": [
        "IDIV ECX           ; EAX = EAX / ECX (signed), EDX = remainder"
      ]
    },
    {
      "mnemonic": "JMP",
      "opcode": "0xE9",
      "operands": ["label"],
      "description": "Unconditional jump to address",
      "cycles": 1,
      "flags": [],
      "examples": [
        "JMP loop_start     ; Jump to label"
      ]
    },
    {
      "mnemonic": "JE",
      "opcode": "0x74",
      "operands": ["label"],
      "description": "Jump if equal (zero flag set)",
      "cycles": 1,
      "flags": [],
      "examples": [
        "JE end_loop        ; Jump if Z flag is set"
      ]
    },
    {
      "mnemonic": "JZ",
      "opcode": "0x74",
      "operands": ["label"],
      "description": "Jump if zero (zero flag set)",
      "cycles": 1,
      "flags": [],
      "examples": [
        "JZ is_zero         ; Jump if Z flag is set"
      ]
    },
    {
      "mnemonic": "JNE",
      "opcode": "0x75",
      "operands": ["label"],
      "description": "Jump if not equal (zero flag clear)",
      "cycles": 1,
      "flags": [],
      "examples": [
        "JNE loop_start     ; Jump if Z flag is clear"
      ]
    },
    {
      "mnemonic": "JNZ",
      "opcode": "0x75",
      "operands": ["label"],
      "description": "Jump if not zero (zero flag clear)",
      "cycles": 1,
      "flags": [],
      "examples": [
        "JNZ loop_start     ; Jump if Z flag is clear"
      ]
    },
    {
      "mnemonic": "PUSH",
      "opcode": "0x50",
      "operands": ["reg/imm"],
      "description": "Push register or immediate value onto stack",
      "cycles": 1,
      "flags": [],
      "examples": [
        "PUSH EAX           ; Push EAX onto stack (ESP -= 4)",
        "PUSH 42            ; Push immediate value onto stack"
      ]
    },
    {
      "mnemonic": "POP",
      "opcode": "0x58",
      "operands": ["reg"],
      "description": "Pop from stack into register",
      "cycles": 1,
      "flags": [],
      "examples": [
        "POP EAX            ; Pop from stack into EAX (ESP += 4)"
      ]
    },
    {
      "mnemonic": "CALL",
      "opcode": "0xE8",
      "operands": ["label"],
      "description": "Call subroutine - pushes return address and jumps to label",
      "cycles": 2,
      "flags": [],
      "examples": [
        "CALL my_function   ; Push return address, jump to function"
      ]
    },
    {
      "mnemonic": "RET",
      "opcode": "0xC3",
      "operands": [],
      "description": "Return from subroutine - pops return address and jumps to it",
      "cycles": 2,
      "flags": [],
      "examples": [
        "RET                ; Pop return address and jump"
      ]
    },
    {
      "mnemonic": "INT",
      "opcode": "0xCD",
      "operands": ["imm8"],
      "description": "Software interrupt - call interrupt handler",
      "cycles": 2,
      "flags": [],
      "examples": [
        "MOV AH, 0x0E       ; Teletype output function",
        "MOV AL, 'H'        ; Character to print",
        "INT 0x10           ; Video services interrupt",
        "",
        "MOV AH, 0x02       ; Write character function",
        "MOV DL, 'A'        ; Character to print",
        "INT 0x21           ; DOS services interrupt",
        "",
        "INT 0x20           ; Terminate program"
      ]
    },
    {
      "mnemonic": "IRET",
      "opcode": "0xCF",
      "operands": [],
      "description": "Return from interrupt handler",
      "cycles": 2,
      "flags": ["All restored from stack"],
      "examples": [
        "IRET               ; Return from interrupt"
      ]
    },
    {
      "mnemonic": "HLT",
      "opcode": "0xF4",
      "operands": [],
      "description": "Halt execution",
      "cycles": 1,
      "flags": [],
      "examples": [
        "HLT                ; Stop execution"
      ]
    }
  ]
}
