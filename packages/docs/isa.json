{
  "version": "1.0",
  "note": "Some instructions are aliases with identical opcodes: JE/JZ (0x74), JNE/JNZ (0x75)",
  "credit": "Verified against x86 Assembly Guide from University of Virginia CS216 by David Evans (https://www.cs.virginia.edu/~evans/cs216/guides/x86.html)",
  "instructions": [
    {
      "mnemonic": "MOV",
      "opcode": "0x89",
      "operands": ["reg/mem", "reg/imm"],
      "description": "Move data",
      "cycles": 1,
      "flags": [],
      "examples": [
        "MOV EAX, 42        ; Load immediate",
        "MOV EAX, ECX       ; Register to register",
        "MOV EAX, 0xF100    ; Read from I/O",
        "MOV 0xF000, 1      ; Write to I/O",
        "MOV AL, 'H'        ; Move character to low byte of EAX",
        "MOV AH, 0x0E       ; Move to high byte of EAX",
        "MOV DL, 65         ; Move to low byte of EDX"
      ]
    },
    {
      "mnemonic": "XCHG",
      "opcode": "0x87",
      "operands": ["reg", "reg"],
      "description": "Exchange values between two registers",
      "cycles": 1,
      "flags": [],
      "examples": ["XCHG EAX, ECX      ; Swap EAX and ECX"]
    },
    {
      "mnemonic": "LEA",
      "opcode": "0x8D",
      "operands": ["reg", "imm/mem"],
      "description": "Load effective address (computes address without memory access)",
      "cycles": 1,
      "flags": [],
      "examples": [
        "LEA EAX, 0x1000    ; Load address into EAX",
        "LEA EAX, [EBX+8]   ; EAX = EBX + 8 (address computation)"
      ]
    },
    {
      "mnemonic": "MOVZX",
      "opcode": "0x0FB6",
      "operands": ["reg", "reg/imm"],
      "description": "Move with zero extend (8-bit to 32-bit)",
      "cycles": 1,
      "flags": [],
      "examples": [
        "MOVZX EAX, ECX     ; Move low byte of ECX to EAX, zero-extend"
      ]
    },
    {
      "mnemonic": "MOVSX",
      "opcode": "0x0FBE",
      "operands": ["reg", "reg/imm"],
      "description": "Move with sign extend (8-bit to 32-bit)",
      "cycles": 1,
      "flags": [],
      "examples": [
        "MOVSX EAX, ECX     ; Move low byte of ECX to EAX, sign-extend"
      ]
    },
    {
      "mnemonic": "ADD",
      "opcode": "0x01",
      "operands": ["reg", "reg"],
      "description": "Add two registers and store result",
      "cycles": 1,
      "flags": ["Z", "C", "O", "S"],
      "examples": ["ADD EAX, ECX       ; EAX = EAX + ECX"]
    },
    {
      "mnemonic": "SUB",
      "opcode": "0x29",
      "operands": ["reg", "reg"],
      "description": "Subtract two registers",
      "cycles": 1,
      "flags": ["Z", "C", "O", "S"],
      "examples": ["SUB EAX, ECX       ; EAX = EAX - ECX"]
    },
    {
      "mnemonic": "CMP",
      "opcode": "0x39",
      "operands": ["reg", "reg/imm"],
      "description": "Compare (SUB without storing result)",
      "cycles": 1,
      "flags": ["Z", "C", "O", "S"],
      "examples": [
        "CMP EAX, 0         ; Compare EAX with 0",
        "CMP EAX, ECX       ; Compare EAX with ECX"
      ]
    },
    {
      "mnemonic": "AND",
      "opcode": "0x21",
      "operands": ["reg", "reg"],
      "description": "Bitwise AND two registers",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": ["AND EAX, ECX       ; EAX = EAX & ECX"]
    },
    {
      "mnemonic": "OR",
      "opcode": "0x09",
      "operands": ["reg", "reg/imm"],
      "description": "Bitwise OR two registers or register with immediate",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": [
        "OR EAX, ECX        ; EAX = EAX | ECX",
        "OR EAX, 0x0F       ; EAX = EAX | 0x0F"
      ]
    },
    {
      "mnemonic": "XOR",
      "opcode": "0x31",
      "operands": ["reg", "reg/imm"],
      "description": "Bitwise XOR two registers or register with immediate",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": [
        "XOR EAX, ECX       ; EAX = EAX ^ ECX",
        "XOR EAX, EAX       ; Clear EAX to 0"
      ]
    },
    {
      "mnemonic": "NOT",
      "opcode": "0xF7",
      "operands": ["reg"],
      "description": "Bitwise NOT (one's complement)",
      "cycles": 1,
      "flags": [],
      "examples": ["NOT EAX            ; EAX = ~EAX"]
    },
    {
      "mnemonic": "NEG",
      "opcode": "0xF7",
      "operands": ["reg"],
      "description": "Two's complement negation",
      "cycles": 1,
      "flags": ["Z", "C", "O", "S"],
      "examples": ["NEG EAX            ; EAX = -EAX"]
    },
    {
      "mnemonic": "TEST",
      "opcode": "0x85",
      "operands": ["reg", "reg/imm"],
      "description": "Logical AND (affects flags only, doesn't store result)",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": [
        "TEST EAX, 0xFF     ; Check if any bits set in lower byte",
        "TEST EAX, ECX      ; Test bits"
      ]
    },
    {
      "mnemonic": "SHL",
      "opcode": "0xC1",
      "operands": ["reg", "imm/reg"],
      "description": "Shift left",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": ["SHL EAX, 4         ; Shift left by 4 positions"]
    },
    {
      "mnemonic": "SHR",
      "opcode": "0xC1",
      "operands": ["reg", "imm/reg"],
      "description": "Shift right (logical, zero-fill)",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": ["SHR EAX, 2         ; Shift right by 2 positions"]
    },
    {
      "mnemonic": "SAR",
      "opcode": "0xC1",
      "operands": ["reg", "imm/reg"],
      "description": "Shift arithmetic right (sign-extend)",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": ["SAR EAX, 3         ; Arithmetic shift right by 3"]
    },
    {
      "mnemonic": "ROL",
      "opcode": "0xC1",
      "operands": ["reg", "imm/reg"],
      "description": "Rotate left",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": ["ROL EAX, 8         ; Rotate left by 8 positions"]
    },
    {
      "mnemonic": "ROR",
      "opcode": "0xC1",
      "operands": ["reg", "imm/reg"],
      "description": "Rotate right",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": ["ROR EAX, 8         ; Rotate right by 8 positions"]
    },
    {
      "mnemonic": "CMP",
      "opcode": "0x39",
      "operands": ["reg", "reg"],
      "description": "Compare two values (SUB without storing result)",
      "cycles": 1,
      "flags": ["Z", "C", "O", "S"]
    },
    {
      "mnemonic": "INC",
      "opcode": "0xFF",
      "operands": ["reg"],
      "description": "Increment register by 1",
      "cycles": 1,
      "flags": ["Z", "O", "S"],
      "examples": ["INC EAX            ; EAX = EAX + 1"]
    },
    {
      "mnemonic": "DEC",
      "opcode": "0xFF",
      "operands": ["reg"],
      "description": "Decrement register by 1",
      "cycles": 1,
      "flags": ["Z", "O", "S"],
      "examples": ["DEC ECX            ; ECX = ECX - 1"]
    },
    {
      "mnemonic": "MUL",
      "opcode": "0xF7",
      "operands": ["reg/imm"],
      "description": "Unsigned multiply (EAX * src -> EDX:EAX)",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": ["MUL ECX            ; EAX = EAX * ECX, overflow in EDX"]
    },
    {
      "mnemonic": "IMUL",
      "opcode": "0xF7",
      "operands": ["reg/imm"],
      "description": "Signed multiply - 1 operand: EAX * src -> EDX:EAX; 2 operands: dest = dest * src; 3 operands: dest = src * imm",
      "cycles": 1,
      "flags": ["Z", "C", "O", "S"],
      "examples": [
        "IMUL ECX           ; EAX = EAX * ECX (signed), overflow in EDX",
        "IMUL EAX, ECX      ; EAX = EAX * ECX",
        "IMUL EAX, ECX, 5   ; EAX = ECX * 5"
      ]
    },
    {
      "mnemonic": "DIV",
      "opcode": "0xF7",
      "operands": ["reg/imm"],
      "description": "Unsigned divide (EAX / src -> quotient in EAX, remainder in EDX)",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": ["DIV ECX            ; EAX = EAX / ECX, EDX = remainder"]
    },
    {
      "mnemonic": "IDIV",
      "opcode": "0xF7",
      "operands": ["reg/imm"],
      "description": "Signed divide (EAX / src -> quotient in EAX, remainder in EDX)",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": [
        "IDIV ECX           ; EAX = EAX / ECX (signed), EDX = remainder"
      ]
    },
    {
      "mnemonic": "MOD",
      "opcode": "0xED",
      "operands": ["reg", "reg/imm"],
      "description": "Modulo operation (dest = dest % src)",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": [
        "MOD EAX, 64        ; EAX = EAX % 64",
        "MOD ECX, EBX       ; ECX = ECX % EBX"
      ]
    },
    {
      "mnemonic": "JMP",
      "opcode": "0xE9",
      "operands": ["label"],
      "description": "Unconditional jump to address",
      "cycles": 1,
      "flags": [],
      "examples": ["JMP loop_start     ; Jump to label"]
    },
    {
      "mnemonic": "JE",
      "opcode": "0x74",
      "operands": ["label"],
      "description": "Jump if equal (zero flag set)",
      "cycles": 1,
      "flags": [],
      "examples": ["JE end_loop        ; Jump if Z flag is set"]
    },
    {
      "mnemonic": "JZ",
      "opcode": "0x74",
      "operands": ["label"],
      "description": "Jump if zero (zero flag set)",
      "cycles": 1,
      "flags": [],
      "examples": ["JZ is_zero         ; Jump if Z flag is set"]
    },
    {
      "mnemonic": "JNE",
      "opcode": "0x75",
      "operands": ["label"],
      "description": "Jump if not equal (zero flag clear)",
      "cycles": 1,
      "flags": [],
      "examples": ["JNE loop_start     ; Jump if Z flag is clear"]
    },
    {
      "mnemonic": "JNZ",
      "opcode": "0x75",
      "operands": ["label"],
      "description": "Jump if not zero (zero flag clear)",
      "cycles": 1,
      "flags": [],
      "examples": ["JNZ loop_start     ; Jump if Z flag is clear"]
    },
    {
      "mnemonic": "JG",
      "opcode": "0x7F",
      "operands": ["label"],
      "description": "Jump if greater (signed): SF == OF and ZF == 0",
      "cycles": 1,
      "flags": [],
      "examples": ["JG greater_handler ; Jump if signed greater"]
    },
    {
      "mnemonic": "JGE",
      "opcode": "0x7D",
      "operands": ["label"],
      "description": "Jump if greater or equal (signed): SF == OF",
      "cycles": 1,
      "flags": [],
      "examples": ["JGE ge_handler     ; Jump if signed greater or equal"]
    },
    {
      "mnemonic": "JL",
      "opcode": "0x7C",
      "operands": ["label"],
      "description": "Jump if less (signed): SF != OF",
      "cycles": 1,
      "flags": [],
      "examples": ["JL less_handler    ; Jump if signed less"]
    },
    {
      "mnemonic": "JLE",
      "opcode": "0x7E",
      "operands": ["label"],
      "description": "Jump if less or equal (signed): SF != OF or ZF == 1",
      "cycles": 1,
      "flags": [],
      "examples": ["JLE le_handler     ; Jump if signed less or equal"]
    },
    {
      "mnemonic": "JS",
      "opcode": "0x78",
      "operands": ["label"],
      "description": "Jump if sign flag set (result is negative)",
      "cycles": 1,
      "flags": [],
      "examples": ["JS negative_handler ; Jump if sign flag is set"]
    },
    {
      "mnemonic": "JNS",
      "opcode": "0x79",
      "operands": ["label"],
      "description": "Jump if sign flag not set (result is non-negative)",
      "cycles": 1,
      "flags": [],
      "examples": ["JNS positive_handler ; Jump if sign flag is clear"]
    },
    {
      "mnemonic": "JA",
      "opcode": "0x77",
      "operands": ["label"],
      "description": "Jump if above (unsigned greater): CF == 0 and ZF == 0",
      "cycles": 1,
      "flags": [],
      "examples": ["JA above_handler   ; Jump if unsigned above"]
    },
    {
      "mnemonic": "JAE",
      "opcode": "0x73",
      "operands": ["label"],
      "description": "Jump if above or equal (unsigned): CF == 0",
      "cycles": 1,
      "flags": [],
      "examples": ["JAE ae_handler     ; Jump if unsigned above or equal"]
    },
    {
      "mnemonic": "JB",
      "opcode": "0x72",
      "operands": ["label"],
      "description": "Jump if below (unsigned less): CF == 1",
      "cycles": 1,
      "flags": [],
      "examples": ["JB below_handler   ; Jump if unsigned below"]
    },
    {
      "mnemonic": "JBE",
      "opcode": "0x76",
      "operands": ["label"],
      "description": "Jump if below or equal (unsigned): CF == 1 or ZF == 1",
      "cycles": 1,
      "flags": [],
      "examples": ["JBE be_handler     ; Jump if unsigned below or equal"]
    },
    {
      "mnemonic": "PUSH",
      "opcode": "0x50",
      "operands": ["reg/imm"],
      "description": "Push register or immediate value onto stack",
      "cycles": 1,
      "flags": [],
      "examples": [
        "PUSH EAX           ; Push EAX onto stack (ESP -= 4)",
        "PUSH 42            ; Push immediate value onto stack"
      ]
    },
    {
      "mnemonic": "POP",
      "opcode": "0x58",
      "operands": ["reg"],
      "description": "Pop from stack into register",
      "cycles": 1,
      "flags": [],
      "examples": ["POP EAX            ; Pop from stack into EAX (ESP += 4)"]
    },
    {
      "mnemonic": "CALL",
      "opcode": "0xE8",
      "operands": ["label"],
      "description": "Call subroutine - pushes return address and jumps to label",
      "cycles": 2,
      "flags": [],
      "examples": ["CALL my_function   ; Push return address, jump to function"]
    },
    {
      "mnemonic": "RET",
      "opcode": "0xC3",
      "operands": [],
      "description": "Return from subroutine - pops return address and jumps to it",
      "cycles": 2,
      "flags": [],
      "examples": ["RET                ; Pop return address and jump"]
    },
    {
      "mnemonic": "INT",
      "opcode": "0xCD",
      "operands": ["imm8"],
      "description": "Software interrupt - call interrupt handler. Supported: INT 0x10 (video), INT 0x20 (terminate), INT 0x21 (DOS services: AH=0x02 write char from DL, AH=0x09 write $-terminated string from [EDX])",
      "cycles": 2,
      "flags": [],
      "examples": [
        "MOV AH, 0x0E       ; Teletype output function",
        "MOV AL, 'H'        ; Character to print",
        "INT 0x10           ; Video services interrupt",
        "",
        "MOV AH, 0x02       ; Write character function",
        "MOV DL, 'A'        ; Character to print",
        "INT 0x21           ; DOS services interrupt",
        "",
        "MOV AH, 0x09       ; Write string function",
        "MOV EDX, msg_addr  ; Address of $-terminated string",
        "INT 0x21           ; DOS services interrupt",
        "",
        "INT 0x20           ; Terminate program"
      ]
    },
    {
      "mnemonic": "IRET",
      "opcode": "0xCF",
      "operands": [],
      "description": "Return from interrupt handler",
      "cycles": 2,
      "flags": ["All restored from stack"],
      "examples": ["IRET               ; Return from interrupt"]
    },
    {
      "mnemonic": "NOP",
      "opcode": "0x90",
      "operands": [],
      "description": "No operation",
      "cycles": 1,
      "flags": [],
      "examples": ["NOP                ; Do nothing"]
    },
    {
      "mnemonic": "HLT",
      "opcode": "0xF4",
      "operands": [],
      "description": "Halt execution",
      "cycles": 1,
      "flags": [],
      "examples": ["HLT                ; Stop execution"]
    },
    {
      "mnemonic": "RAND",
      "opcode": "0xEE",
      "operands": ["reg", "reg/imm"],
      "description": "Generate random number from 0 to max-1, store in dest",
      "cycles": 1,
      "flags": ["Z", "S"],
      "examples": [
        "RAND EAX, 64       ; EAX = random(0..63)",
        "RAND EBX, ECX      ; EBX = random(0..ECX-1)"
      ]
    },
    {
      "mnemonic": "LOOP",
      "opcode": "0xE2",
      "operands": ["label"],
      "description": "Decrement ECX, jump to label if ECX != 0",
      "cycles": 1,
      "flags": [],
      "examples": ["LOOP my_loop       ; Decrement ECX, jump if ECX != 0"]
    },
    {
      "mnemonic": "LOOPE",
      "opcode": "0xE1",
      "operands": ["label"],
      "description": "Decrement ECX, jump if ECX != 0 AND ZF set (alias: LOOPZ)",
      "cycles": 1,
      "flags": [],
      "examples": ["LOOPE my_loop      ; Loop while equal and ECX != 0"]
    },
    {
      "mnemonic": "LOOPZ",
      "opcode": "0xE1",
      "operands": ["label"],
      "description": "Decrement ECX, jump if ECX != 0 AND ZF set (alias for LOOPE)",
      "cycles": 1,
      "flags": [],
      "examples": ["LOOPZ my_loop      ; Loop while zero and ECX != 0"]
    },
    {
      "mnemonic": "LOOPNE",
      "opcode": "0xE0",
      "operands": ["label"],
      "description": "Decrement ECX, jump if ECX != 0 AND ZF clear (alias: LOOPNZ)",
      "cycles": 1,
      "flags": [],
      "examples": ["LOOPNE my_loop     ; Loop while not equal and ECX != 0"]
    },
    {
      "mnemonic": "LOOPNZ",
      "opcode": "0xE0",
      "operands": ["label"],
      "description": "Decrement ECX, jump if ECX != 0 AND ZF clear (alias for LOOPNE)",
      "cycles": 1,
      "flags": [],
      "examples": ["LOOPNZ my_loop     ; Loop while not zero and ECX != 0"]
    },
    {
      "mnemonic": "RCL",
      "opcode": "0xD1",
      "operands": ["reg", "imm/reg"],
      "description": "Rotate left through carry flag",
      "cycles": 1,
      "flags": ["C", "O"],
      "examples": [
        "RCL EAX, 1         ; Rotate EAX left through CF by 1",
        "RCL EBX, CL        ; Rotate EBX left through CF by CL"
      ]
    },
    {
      "mnemonic": "RCR",
      "opcode": "0xD1",
      "operands": ["reg", "imm/reg"],
      "description": "Rotate right through carry flag",
      "cycles": 1,
      "flags": ["C", "O"],
      "examples": [
        "RCR EAX, 1         ; Rotate EAX right through CF by 1",
        "RCR EBX, CL        ; Rotate EBX right through CF by CL"
      ]
    },
    {
      "mnemonic": "LAHF",
      "opcode": "0x9F",
      "operands": [],
      "description": "Load flags (SF, ZF, CF) into AH register",
      "cycles": 1,
      "flags": [],
      "examples": ["LAHF                ; AH = flags (SF:ZF:0:AF:0:PF:1:CF)"]
    },
    {
      "mnemonic": "SAHF",
      "opcode": "0x9E",
      "operands": [],
      "description": "Store AH register into flags (SF, ZF, CF)",
      "cycles": 1,
      "flags": ["Z", "C", "S"],
      "examples": ["SAHF                ; flags = AH"]
    },
    {
      "mnemonic": "CMOVE",
      "opcode": "0x0F44",
      "operands": ["reg", "reg/imm"],
      "description": "Conditional move if equal (ZF=1). Alias: CMOVZ",
      "cycles": 1,
      "flags": [],
      "examples": ["CMOVE EAX, EBX     ; Move EBX to EAX if ZF=1"]
    },
    {
      "mnemonic": "CMOVZ",
      "opcode": "0x0F44",
      "operands": ["reg", "reg/imm"],
      "description": "Conditional move if zero (ZF=1). Alias for CMOVE",
      "cycles": 1,
      "flags": [],
      "examples": ["CMOVZ EAX, EBX     ; Move EBX to EAX if ZF=1"]
    },
    {
      "mnemonic": "CMOVNE",
      "opcode": "0x0F45",
      "operands": ["reg", "reg/imm"],
      "description": "Conditional move if not equal (ZF=0). Alias: CMOVNZ",
      "cycles": 1,
      "flags": [],
      "examples": ["CMOVNE EAX, EBX    ; Move EBX to EAX if ZF=0"]
    },
    {
      "mnemonic": "CMOVNZ",
      "opcode": "0x0F45",
      "operands": ["reg", "reg/imm"],
      "description": "Conditional move if not zero (ZF=0). Alias for CMOVNE",
      "cycles": 1,
      "flags": [],
      "examples": ["CMOVNZ EAX, EBX    ; Move EBX to EAX if ZF=0"]
    },
    {
      "mnemonic": "CMOVL",
      "opcode": "0x0F4C",
      "operands": ["reg", "reg/imm"],
      "description": "Conditional move if less (signed: SF!=OF)",
      "cycles": 1,
      "flags": [],
      "examples": ["CMOVL EAX, EBX     ; Move if signed less"]
    },
    {
      "mnemonic": "CMOVLE",
      "opcode": "0x0F4E",
      "operands": ["reg", "reg/imm"],
      "description": "Conditional move if less or equal (SF!=OF or ZF=1)",
      "cycles": 1,
      "flags": [],
      "examples": ["CMOVLE EAX, EBX    ; Move if signed less or equal"]
    },
    {
      "mnemonic": "CMOVG",
      "opcode": "0x0F4F",
      "operands": ["reg", "reg/imm"],
      "description": "Conditional move if greater (signed: SF==OF and ZF=0)",
      "cycles": 1,
      "flags": [],
      "examples": ["CMOVG EAX, EBX     ; Move if signed greater"]
    },
    {
      "mnemonic": "CMOVGE",
      "opcode": "0x0F4D",
      "operands": ["reg", "reg/imm"],
      "description": "Conditional move if greater or equal (SF==OF)",
      "cycles": 1,
      "flags": [],
      "examples": ["CMOVGE EAX, EBX    ; Move if signed greater or equal"]
    },
    {
      "mnemonic": "CMOVA",
      "opcode": "0x0F47",
      "operands": ["reg", "reg/imm"],
      "description": "Conditional move if above (unsigned: CF=0 and ZF=0)",
      "cycles": 1,
      "flags": [],
      "examples": ["CMOVA EAX, EBX     ; Move if unsigned above"]
    },
    {
      "mnemonic": "CMOVAE",
      "opcode": "0x0F43",
      "operands": ["reg", "reg/imm"],
      "description": "Conditional move if above or equal (CF=0)",
      "cycles": 1,
      "flags": [],
      "examples": ["CMOVAE EAX, EBX    ; Move if unsigned above or equal"]
    },
    {
      "mnemonic": "CMOVB",
      "opcode": "0x0F42",
      "operands": ["reg", "reg/imm"],
      "description": "Conditional move if below (CF=1)",
      "cycles": 1,
      "flags": [],
      "examples": ["CMOVB EAX, EBX     ; Move if unsigned below"]
    },
    {
      "mnemonic": "CMOVBE",
      "opcode": "0x0F46",
      "operands": ["reg", "reg/imm"],
      "description": "Conditional move if below or equal (CF=1 or ZF=1)",
      "cycles": 1,
      "flags": [],
      "examples": ["CMOVBE EAX, EBX    ; Move if unsigned below or equal"]
    },
    {
      "mnemonic": "CMOVS",
      "opcode": "0x0F48",
      "operands": ["reg", "reg/imm"],
      "description": "Conditional move if sign (SF=1)",
      "cycles": 1,
      "flags": [],
      "examples": ["CMOVS EAX, EBX     ; Move if sign flag set"]
    },
    {
      "mnemonic": "CMOVNS",
      "opcode": "0x0F49",
      "operands": ["reg", "reg/imm"],
      "description": "Conditional move if not sign (SF=0)",
      "cycles": 1,
      "flags": [],
      "examples": ["CMOVNS EAX, EBX    ; Move if sign flag clear"]
    },
    {
      "mnemonic": "XADD",
      "opcode": "0x0FC1",
      "operands": ["reg", "reg"],
      "description": "Exchange and add: adds source to destination, loads old destination into source",
      "cycles": 1,
      "flags": ["Z", "C", "O", "S"],
      "examples": ["XADD EAX, EBX      ; Temp=EAX; EAX=EAX+EBX; EBX=Temp"]
    },
    {
      "mnemonic": "BSF",
      "opcode": "0x0FBC",
      "operands": ["reg", "reg/imm"],
      "description": "Bit scan forward - find index of least significant set bit",
      "cycles": 1,
      "flags": ["Z"],
      "examples": ["BSF EAX, EBX       ; EAX = index of first set bit in EBX"]
    },
    {
      "mnemonic": "BSR",
      "opcode": "0x0FBD",
      "operands": ["reg", "reg/imm"],
      "description": "Bit scan reverse - find index of most significant set bit",
      "cycles": 1,
      "flags": ["Z"],
      "examples": ["BSR EAX, EBX       ; EAX = index of last set bit in EBX"]
    },
    {
      "mnemonic": "BSWAP",
      "opcode": "0x0FC8",
      "operands": ["reg"],
      "description": "Byte swap - reverse byte order (endianness conversion)",
      "cycles": 1,
      "flags": [],
      "examples": [
        "BSWAP EAX           ; Reverse byte order: 0x12345678 -> 0x78563412"
      ]
    },
    {
      "mnemonic": "LODSB",
      "opcode": "0xAC",
      "operands": [],
      "description": "Load string byte: load byte from [ESI] into AL, increment ESI",
      "cycles": 1,
      "flags": [],
      "examples": ["LODSB               ; AL = [ESI]; ESI++"]
    },
    {
      "mnemonic": "LODS",
      "opcode": "0xAC",
      "operands": [],
      "description": "Load string byte (alias for LODSB): load byte from [ESI] into AL, increment ESI",
      "cycles": 1,
      "flags": [],
      "examples": ["LODS                ; AL = [ESI]; ESI++"]
    },
    {
      "mnemonic": "STOSB",
      "opcode": "0xAA",
      "operands": [],
      "description": "Store string byte: store AL to [EDI], increment EDI",
      "cycles": 1,
      "flags": [],
      "examples": ["STOSB               ; [EDI] = AL; EDI++"]
    },
    {
      "mnemonic": "STOS",
      "opcode": "0xAA",
      "operands": [],
      "description": "Store string byte (alias for STOSB): store AL to [EDI], increment EDI",
      "cycles": 1,
      "flags": [],
      "examples": ["STOS                ; [EDI] = AL; EDI++"]
    },
    {
      "mnemonic": "MOVSB",
      "opcode": "0xA4",
      "operands": [],
      "description": "Move string byte: copy byte from [ESI] to [EDI], increment both",
      "cycles": 1,
      "flags": [],
      "examples": ["MOVSB               ; [EDI] = [ESI]; ESI++; EDI++"]
    },
    {
      "mnemonic": "MOVS",
      "opcode": "0xA4",
      "operands": [],
      "description": "Move string byte (alias for MOVSB): copy byte from [ESI] to [EDI], increment both",
      "cycles": 1,
      "flags": [],
      "examples": ["MOVS                ; [EDI] = [ESI]; ESI++; EDI++"]
    },
    {
      "mnemonic": "SCASB",
      "opcode": "0xAE",
      "operands": [],
      "description": "Scan string byte: compare AL with byte at [EDI], set flags, increment EDI",
      "cycles": 1,
      "flags": ["Z", "C", "O", "S"],
      "examples": [
        "SCASB               ; Compare AL with [EDI]; set flags; EDI++"
      ]
    },
    {
      "mnemonic": "SCAS",
      "opcode": "0xAE",
      "operands": [],
      "description": "Scan string byte (alias for SCASB): compare AL with byte at [EDI], set flags, increment EDI",
      "cycles": 1,
      "flags": ["Z", "C", "O", "S"],
      "examples": [
        "SCAS                ; Compare AL with [EDI]; set flags; EDI++"
      ]
    },
    {
      "mnemonic": "CMPSB",
      "opcode": "0xA6",
      "operands": [],
      "description": "Compare string bytes: compare [ESI] with [EDI], set flags, increment both",
      "cycles": 1,
      "flags": ["Z", "C", "O", "S"],
      "examples": [
        "CMPSB               ; Compare [ESI] with [EDI]; set flags; ESI++; EDI++"
      ]
    },
    {
      "mnemonic": "CMPS",
      "opcode": "0xA6",
      "operands": [],
      "description": "Compare string bytes (alias for CMPSB): compare [ESI] with [EDI], set flags, increment both",
      "cycles": 1,
      "flags": ["Z", "C", "O", "S"],
      "examples": [
        "CMPS                ; Compare [ESI] with [EDI]; set flags; ESI++; EDI++"
      ]
    },
    {
      "mnemonic": "INT3",
      "opcode": "0xCC",
      "operands": [],
      "description": "Breakpoint interrupt - triggers a debugger breakpoint and halts execution",
      "cycles": 1,
      "flags": [],
      "examples": ["INT3                ; Trigger breakpoint"]
    }
  ]
}
